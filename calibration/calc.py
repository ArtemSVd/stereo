import numpy as np


#  [alpha,beta,theta,x0,y0,R,t] = calc_params(projmatrix)
#  
#  Вычисление внутренних и внешних параметров камеры по заданным
#  значениям компонент проекционной матрицы.
# 
#  Входные параметры:
#    projmatrix = 3x4 матрица - проекционная матрица камеры
# 
#  Выходные параметры:
#    alpha = число - отношение fF/sx (отношение фокусного расстояния к
#        горизонтальному размеру пиксела фотоматрицы камеры)
#    beta = число - отношение fF/sy (отношение фокусного расстояния к
#        вертикальному размеру пиксела фотоматрицы камеры)
#    theta = число - угол, определяющий непрямоугольность пиксела
#        фотоматрицы
#    x0 = число - положение начала координат физического изображения
#        в системе координат цифрового изображения IxOL
#    y0 = число - положение начала координат физического изображения
#        в системе координат цифрового изображения IyOL
#    R = 3x3 матрица - матрица CJR поворота преобразования координат (J)->(C)
#    t = 3x1 вектор - вектор смещения преобразования координат (J)->(C)
#
def calc_params(projmatrix):
    # Проверка размерности проекционной матрицы
    if projmatrix.shape[0] != 3 or projmatrix.shape[1] != 4:
        raise Exception('error in calc_params() : invalid size of projmatrix!')

    # Разбиваем проекционную матрицу на A и b (формула (30))
    A = projmatrix[:, 0:3]
    b = projmatrix[:, 3]

    # Вычисляем ro (формулы (33) и (34))
    ro = 1 / np.linalg.norm(A[2, :], 2)
    if b[2] > 0:
        ro = -ro

    # Вычисляем x0 и y0 (формула (41))
    x0 = ro * ro * np.multiply(A[0, :], A[2, :]).sum(axis=0)
    y0 = ro * ro * np.multiply(A[1, :], A[2, :]).sum(axis=0)

    # Вычисляем R(2,:) (формула (35))
    R = np.zeros((3, 3))
    R[2, :] = ro * A[2, :]

    # Вычисляем theta (из формулы (47))
    cross13 = np.cross(A[0, :], A[2, :])
    cross23 = np.cross(A[1, :], A[2, :])
    cos_theta = np.multiply(cross13, cross23).sum(axis=0) / (np.linalg.norm(cross13, 2) * np.linalg.norm(cross23, 2))
    theta = np.arccos(cos_theta)

    # Вычисляем alpha и beta (формула (45))
    alpha = ro * ro * np.linalg.norm(cross13, 2) * np.sin(theta)
    beta = ro * ro * np.linalg.norm(cross23, 2) * np.sin(theta)

    # Вычисляем R(0,:) (формула (48))
    R[0, :] = - (np.sin(theta) * ro * ro / beta) * cross23

    # Вычисляем R(1,:) (формула (49))
    R[1, :] = np.cross(R[2, :], R[0, :])

    # Вычисляем t (формула (50))
    t = np.zeros((3, 1))
    t[2] = ro * b[2]
    t[1] = - (ro * b[1] - y0 * t[2]) / (beta / np.sin(theta))
    t[0] = (ro * b[0] + alpha * (1 / np.tan(theta)) * t[1] - x0 * t[2]) / alpha

    return [alpha, beta, theta, x0, y0, R, t]


#  Вычисление компонент калибровочной матрицы по заданным внутренним
#  параметрам камеры
# 
#  Входные параметры:
#    alpha = число - отношение fF/sx (отношение фокусного расстояния к
#        горизонтальному размеру пиксела фотоматрицы камеры)
#    beta = число - отношение fF/sy (отношение фокусного расстояния к
#        вертикальному размеру пиксела фотоматрицы камеры)
#    theta = число - угол, определяющий непрямоугольность пиксела
#        фотоматрицы
#    x0 = число - положение начала координат физического изображения
#        в системе координат цифрового изображения IxOL
#    y0 = число - положение начала координат физического изображения
#        в системе координат цифрового изображения IyOL
# 
#  Выходные параметры:
#    calmatrix = 3x4 матрица - калибровочная матрица камеры
def calc_calmatrix(alpha, beta, theta, x0, y0):
    # сразу выделяем место под матрицу
    calmatrix = np.zeros((3, 4))

    # вычисляем компоненты матрицы в соответствии с формулой (23)
    calmatrix[0, 0] = alpha
    calmatrix[0, 1] = -alpha * 1 / np.tan(theta)
    calmatrix[0, 2] = x0

    calmatrix[1, 1] = -beta / np.sin(theta)
    calmatrix[1, 2] = y0

    calmatrix[2, 2] = 1

    return calmatrix


#  Вычисление компонент проекционной матрицы по заданным внутренним и внешним параметрам камеры
#  (Для вычисления проекционной матрицы используется формула (24) методического пособия)
#
#  Входные  параметры:
#  calmatrix = 3x4 матрица - калибровочная матрица камеры
#
#  R = 3x3 матрица - матрица CJR поворота преобразования координат(J)->(C)
#
#  t = 3x1 вектор - вектор смещения преобразования координат(J)->(C)
#
#  Выходные параметры:
#  projmatrix = 3x4 матрица - проекционная матрица камеры
#
#  Проверка размерностей входных параметров(в случае ошибки возвращаем  нулевую проекционную матрицу)
def calc_projmatrix(calmatrix, R, t):
    if calmatrix.shape[0] != 3 \
            or calmatrix.shape[1] != 4 \
            or R.shape[0] != 3 \
            or R.shape[1] != 3 \
            or t.shape[0] != 3 \
            or t.shape[1] != 1:
        raise Exception("error in calc_projmatrix() : invalid size of input parameters!")

    #  формируем матрицу T из R и t
    T = np.concatenate((R, t), axis=1)
    T = np.vstack([T, [0, 0, 0, 1]])

    #  вычисляем проекционную матрицу(формула(24))
    return np.dot(calmatrix, T)


#
#  I0 = S x N матрица (правильные данные)
#  I1 = S x N матрица (проверяемые данные)
#
#  residual = число - относительная ошибка:  residual = sum(|I1-I0|)/(sum(|I0|)+1)
def calc_residual(I0, I1):
    S = I0.shape[0]
    N = I0.shape[1]

    A = 0
    B = 0

    for i in range(N):
        A = A + np.linalg.norm(I1[:, i] - I0[:, i], 2)
        B = B + np.linalg.norm(I0[:, i], 2)

    return A / (B + 1)  # здесь 1 добавляется во избежание деления на ноль
